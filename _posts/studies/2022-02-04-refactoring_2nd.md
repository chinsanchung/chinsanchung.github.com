---
title: "(책) 리팩터링 2판"
layout: single
author_profile: false
read_time: false
comments: false
share: true
related: true
categories:
  - study
toc: true
toc_sticky: true
toc_labe: 목차
description: 마틴 파울러의 『리팩터링 2판』을 읽으며 내용을 정리합니다.
excerpt: 마틴 파울러의 『리팩터링 2판』을 읽으며 내용을 정리합니다.
tags:
  - book
---

마틴 파울러의 『리팩터링 2판』에 대해 정리하는 목적의 글입니다.

## 1. 리팩터링 - 첫 번째 예시

### 1.2 예시 프로그램을 본 소감

> 프로그램이 새운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다. - p.27

처음 작성할 때 그 당시의 상황만 고려하여 함수를 작성하는 방식은 이후에 새로운 요구사항이 발생할 경우 전체를 수정할 가능성이 있어 비효율적입니다.

### 1.3 리팩터링의 첫 단계

> 리팩터링의 첫 단계는 항상 똑같다. 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야 한다. - p.28

저자는 여러 가지 사례를 미리 작성한 후, 성공과 실패를 스스로 판단하는 자가진단 테스트로 만들어 테스트를 수행한다고 합니다. 또한 리팩터링을 테스트에 상당히 의지하여 수행하고, 테스트를 통해 버그의 가능성을 줄인다고 언급합니다. 이 점은 저도 공감하는 부분인데, 이전에 실패의 조건을 놓친 채로 성급하게 커밋을 올려 후회한 경험이 있기 때문입니다. 지금은 테스트 케이스를 먼저 작성한 후에 초기 코드를 리팩터링하는 식으로 기능을 구현하는데, 이전보다 확실히 실수가 줄었음을 채감하고 있습니다.

### 1.4 statement() 함수 쪼개기

> statement()처럼 긴 함수를 리팩터링할 때는 먼저 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다. - p.29

우선 switch 문을 하나의 함수로 추출합니다. 내부에서 사용하는 변수 중에서 값이 바뀌지 않는 것을 매개변수로, 값이 바뀌는 것은 내부의 지역 변수로 선언합니다. 이렇게 코드의 조각을 함수를 추출하는 과정을 저자는 **함수 추출하기**라는 이름을 붙이고 있습니다.

조금식 변경하고 매번 테스트하는 것이 리팩터링의 핵심이며 한 번에 너무 많이 수정하려다 실수를 저지르면 디버깅이 어려워진다는 글을 읽고, 저 자신은 후자의 방식으로 진행하고 있음을 깨달았습니다. 작은 기능을 리팩터링할 때마다 테스트를 수행하는 습관을 들여야겠습니다.

추출한 함수 `amountFor`의 변수, 인수의 이름을 수정합니다. 반환 값을 result 라 하는 부분은 괜찮은 방법이라 느꼈습니다. 매개변수 이름에 접두어로 타입 이름을 적는 방식은 아직은 잘 이해가 가질 않습니다. 여기서는 `perf`를 `aPerformance`로 바꿨는데, 매개변수의 역할이 뚜렷하지 않아 부정 관사(a/an)을 붙인 것이라 합니다.

```javascript
function amountFor(aPerformance, play) {
  let result = 0;
  switch (play.type) {
    default:
    // ...
  }
  return result;
}
```

---

이번에는 임시 변수 `play`를 제거합니다. 이러한 임시 변수를 최대한 제거하지 않으면, 로컬 범위에 존재하는 이름이 늘어나 추출 작업이 복잡해진다고 합니다. 즉, 반대로 발하면 지역 변수를 제거하면 추출 작업이 쉬워지는 장점이 있습니다. 이러한 리팩터링을 **임시 변수를 질의 함수로 바꾸기**라고 부릅니다.

1. 질의 함수 만들기

```javascript
function playFor(aPerformance) {
  return plays[aPerformance.playID];
}
```

statement 함수에서의 `play` 변수의 값을 질의 함수로 불러오도록 수정합니다.

```javascript
function statement(invoice, plays) {
  // ...
  for (let perf of invoice.performances) {
    const play = playFor(perf);
  }
}
```
