---
title: "원티드 프리온보딩 코스 첫 번째 과제 후기"
layout: single
author_profile: false
read_time: false
comments: false
share: true
related: true
categories:
  - review
toc: true
toc_sticky: true
toc_labe: 목차
description: aimmo 에서 제시해주신 게시글 API 과제의 제작 과정을 정리합니다.
excerpt: aimmo 에서 제시해주신 게시글 API 과제의 제작 과정을 정리합니다.
tags:
  - 위코드
  - 원티드
  - aimmo
---

원티드와 위코드에서 지원하는 [원티드 프리온보딩 백엔드 코스](https://www.wanted.co.kr/events/pre_onboarding_course_4)의 첫 과제를 수행한 경험을 정리합니다. [GitHub Repository](https://github.com/chinsanchung/preonboarding-aimmo)에서 코드를 확인하실 수 있습니다.

## 개요

이번 첫 번째 프로젝트는 [aimmo](https://aimmo.co.kr/)에서 제시한 과제로, **aimmo**는 인공지능의 활용을 원하는 산업·기업에서 정확한 AI 모델을 쉽고 빠르게 만들 수 있도록 데이터 라이프 사이클의 전 과정을 지원하는 기업입니다.

### 과제 안내

주제는 게시글 API 를 만드는 것으로, 세부적인 사항은 아래와 같습니다.

- 게시글 카테고리
- 게시글 검색
- 대댓글(1 depth)
  - 대댓글 pagination
- 게시글 읽힘 수
  - 같은 User가 게시글을 읽는 경우 count 수 증가하면 안 됨
- Rest API 설계
- Unit Test
- 1000만건 이상의 데이터를 넣고 성능테스트 진행 결과 필요

## 회고

### 데이터 스키마 설계 및 기본 설정

#### 데이터 스키마 설계

데이터 구조를 설계하는 것을 최우선으로 시작했습니다. 모여서 회의를 했는데, 처음의 데이터 구조는 아래 그림과 같았습니다.

![첫 번째 erd](https://github.com/chinsanchung/chinsanchung.github.com/blob/master/assets/images/2021-11-03-preonboarding-first-erd_1.PNG?raw=true)

하지만 개발을 진행하면서, 댓글의 배열 또는 대댓글의 배열로 하는 구조에서는 pagination, 삭제하지 않은 댓글만을 목록으로 불러오는 처리, 그리고 특성 댓글 삭제를 수행하는 것이 까다롭고 어렵다는 것을 알게 되었습니다.

그래서 다시 고민을 했는데, 다른 사이트의 게시판을 살펴보면서, 1. 게시글을 조회할 때는 본문과 첫 번째 댓글 페이지를 보여준다는 것, 2. 페이지 버튼으로 댓글 pagination 을 수행하지만 url query 가 바뀌지 않는 점, 마지막 3. 댓글의 댓글은 따로 버튼을 클릭해서 불러온다는 것을 확인했습니다.

그래서 생각한 것이 댓글과 대댓글의 API 를 새로 만들어서 댓글들만 새로 받아오도록 수행하는 것이라 가정을 했습니다. 그리고 댓글이나 대댓글 모두 도큐먼트 안의 배열로 하지 말고, 아래 그림처럼 다 따로 저장하는 형식으로 수정하면 댓글이나 대댓글 삭제도 저번보다 더 간단한 작업이 가능하다고 판단했습니다.

조원들과 의논한 결과 아래 그림과 같이 데이터베이스를 다시 설계했습니다. 다행히 NoSQL 이라 엄격한 기준을 적용하지 않기에 구조를 바꾸더라도 큰 문제를 일으키지는 않았습니다.

![두 번째 erd](https://github.com/lhj0621/imagetemp/blob/master/2021-11-03%2004;10;50.PNG?raw=true)

#### 기본 설정

다행히 1년 동안 mongodb 를 이용해서 개발을 했기 때문에 [mongo atlas](https://www.mongodb.com/atlas/database)를 이용한 서버 생성과, 애플리케이션에 코드를 작성해 데이터베이스에 접근할 수 있도록 설정하는 것은 수월하게 진행했습니다.
그리고 Express APP 에 cookie-parser 같은 미들웨어를 연결하고 앱을 실행하는 코드를 조원들과 함께 작성했습니다.

### 개발 진행

#### 형상 관리

혼자 하는 것이 아니다보니, 제 마음대로 커밋 메시지나 브랜치 이름을 정하지 않고, 조원들과 서로 합의한 기준으로 형상 관리를 했습니다. 그 기준은 아래와 같습니다.

- 브랜치 원칙
  - `main` - 운영 서버 배포 브런치
  - `develop` - 테스트 서버 배포 브런치
  - `feature` - 각 기능별 브런치 (ex. feature/kafka)
  - 네이밍은 케밥케이스를 사용한다(ex : branch-name-1)
- 커밋의 원칙(제목)
  - `feat` - 신규 기능 추가
  - `fix` - 버그 수정
  - `docs` - 문서 수정
  - `style` - 코딩 스타일 관련(로직 변경x)
  - `refactor` - 코드 리팩터링
  - `test` - 테스트 코드 관련
  - `ci` - CI/CD 관련
  - `chore` - 기타
- Pull Request 의 원칙
  - 지정한 양식에 맞게 작성할 것
  - 글의 마지막 또는 처음에 `resolves: #1`과 같은 형식으로 깃허브의 Issues 와 연동하기

혼자서 형상 관리를 할 때는 브랜치를 따로 만들어서 Pull Request 를 보내거나 커밋의 제목을 신경쓰지는 않았는데, 이번 과제를 통해 협업을 위한 형상 관리가 무엇인지를 확실히 알 수 있었습니다.

또한, 깃허브에서 제공하는 Issue, Project 탭의 기능으로 마치 Jira 처럼 일정과 업무를 조율할 수 있다는 것을 배웠습니다.

#### 짝 프로그래밍

멘토님께서 짝 프로그래밍을 언급하셨기에, 화면 공유를 통해 코드를 함께 작성하면서 의견을 주고받거나 이미 작성한 코드에서 수정하거나 개선할 점은 없는지를 의논하면서 되도록 함께 코드를 작성하는 데에 중점을 두었습니다.

#### 프로젝트의 구조 및 배포

전반적인 구조는 저의 [프리온보딩 사전 과제](https://github.com/chinsanchung/board-api-assignment)를 참고하여 진행하기로 협의했습니다.

- 각 기능을 따온 폴더명에 API 기능을 작성한 코드를 저장합니다.
- 요청과 응답을 받는 컨트롤러, 데이터베이스에 접근해 비즈니스 로직을 수행하는 서비스로 구분합니다.
- core 폴더에 Express App, mongoose Database 설정을 저장합니다.

그리고 이번에는 타입스크립트를 이용해 코드를 작성함으로써 오류를 방지하는 동시에 업무의 효율성을 높였습니다.

마지막으로 배포는 [헤로쿠](https://www.heroku.com/)를 이용했습니다. 그 이유는 무료로 서버와 도메인을 제공한다는 점, 그리고 간편하게 배포를 지원하고 마지막으로 깃허브 레포지토리와 연동해서 자동으로 재배포를 해주는 점이 매력적이었기 떄문입니다.

## 3. 프로젝트를 마치며

1. 이틀이라는 짧은 기간 내에 프로젝트를 제작하는 과정은 어려웠습니다. 조원들과 협업하면서 형상 관리에 신경을 써야 하는 부분은 비록 제대로 작성해야 한다는 압박감은 있었지만, 그 덕분에 깔끔하게 기록을 남길 수 있었고, 프로젝트의 진행 과정을 더욱 상세하게 알 수 있었습니다.

2. 최대한 짝 프로그래밍으로 하려고 했지만 그것이 처음이었던 점, 그리고 시간의 부족으로 각자 역할을 맡아서 코드를 작성했기 때문에 결과물에서 약간의 구조적인 차이점이 생겼습니다. 그것을 보고 엄격하게 규칙을 명시한 프레임워크가 왜 필요한지를 이해했습니다. 최근에 인터넷 강의로 NestJS 를 공부하고 있어서 이 점이 더 크게 와닿았습니다. 만약 다음 과제를 수행할 때 팀원 분들이 전부 NestJS 를 공부를 하셨다면 이것으로 과제를 제작하면 어떨까 생각했습니다.

3. 아쉬웠던 점은 시간의 제약으로 기업에서 제시한 기준 중에서 유닛 테스트와 1,000만 건 이상의 데이터로 성능 테스트를 수행하지 못한 것입니다. 중간에 데이터베이스 스키마를 변경하며 시간을 지체한 것이 그 원인이라 생각하고, 다음부턴 처음에 최대한 올바르게 설계하여 수정하는 일이 없도록 주의를 기울여야겠다고 느꼈습니다.
